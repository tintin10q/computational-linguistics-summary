<!DOCTYPE html><html><head><meta content="text/html; charset=utf-8" http-equiv="Content-Type" /><meta content="width=device-width, initial-scale=1" name="viewport" /><!--replace-start-0--><!--replace-start-5--><!--replace-start-8--><title>Grammers - Neuron Zettelkasten</title><!--replace-end-8--><!--replace-end-5--><!--replace-end-0--><link href="https://cdn.jsdelivr.net/npm/fomantic-ui@2.8.7/dist/semantic.min.css" rel="stylesheet" /><link href="https://fonts.googleapis.com/css?family=Merriweather|Libre+Franklin|Roboto+Mono&amp;display=swap" rel="stylesheet" /><!--replace-start-1--><!--replace-start-4--><!--replace-start-7--><link href="https://raw.githubusercontent.com/srid/neuron/master/assets/neuron.svg" rel="icon" /><meta content="A grammer is a language for defining languages. If you write rules for a language then these rules are also called the grammar. The individual rules you write are called a production. Grammars define the structure of the sentences in the language." name="description" /><link href="https://neuron.zettel.page/Grammar.html" rel="canonical" /><meta content="Grammers" property="og:title" /><meta content="Neuron Zettelkasten" property="og:site_name" /><meta content="article" property="og:type" /><meta content="Grammar" property="neuron:zettel-id" /><meta content="Grammar" property="neuron:zettel-slug" /><meta content="root/Languages" property="neuron:zettel-tag" /><script type="application/ld+json">[{"@context":"https://schema.org","itemListElement":[{"name":"Languages","item":"https://neuron.zettel.page/Languages.html","@type":"ListItem","position":1}],"@type":"BreadcrumbList"}]</script><style type="text/css">body{background-color:#eeeeee !important;font-family:"Libre Franklin", serif !important}body .ui.container{font-family:"Libre Franklin", serif !important}body h1, h2, h3, h4, h5, h6, .ui.header, .headerFont{font-family:"Merriweather", sans-serif !important}body code, pre, tt, .monoFont{font-family:"Roboto Mono","SFMono-Regular","Menlo","Monaco","Consolas","Liberation Mono","Courier New", monospace !important}body div.z-index p.info{color:#808080}body div.z-index ul{list-style-type:square;padding-left:1.5em}body div.z-index .uplinks{margin-left:0.29999em}body .zettel-content h1#title-h1{background-color:rgba(33,133,208,0.1)}body nav.bottomPane{background-color:rgba(33,133,208,2.0e-2)}body div#footnotes{border-top-color:#2185d0}body p{line-height:150%}body img{max-width:100%}body .deemphasized{font-size:0.94999em}body .deemphasized:hover{opacity:1}body .deemphasized:not(:hover){opacity:0.69999}body .deemphasized:not(:hover) a{color:#808080 !important}body div.container.universe{padding-top:1em}body div.zettel-view ul{padding-left:1.5em;list-style-type:square}body div.zettel-view .pandoc .highlight{background-color:#ffff00}body div.zettel-view .pandoc .ui.disabled.fitted.checkbox{margin-right:0.29999em;vertical-align:middle}body div.zettel-view .zettel-content .metadata{margin-top:1em}body div.zettel-view .zettel-content .metadata div.date{text-align:center;color:#808080}body div.zettel-view .zettel-content h1{padding-top:0.2em;padding-bottom:0.2em;text-align:center}body div.zettel-view .zettel-content h2{border-bottom:solid 1px #4682b4;margin-bottom:0.5em}body div.zettel-view .zettel-content h3{margin:0px 0px 0.4em 0px}body div.zettel-view .zettel-content h4{opacity:0.8}body div.zettel-view .zettel-content div#footnotes{margin-top:4em;border-top-style:groove;border-top-width:2px;font-size:0.9em}body div.zettel-view .zettel-content div#footnotes ol > li > p:only-of-type{display:inline;margin-right:0.5em}body div.zettel-view .zettel-content aside.footnote-inline{width:30%;padding-left:15px;margin-left:15px;float:right;background-color:#d3d3d3}body div.zettel-view .zettel-content .overflows{overflow:auto}body div.zettel-view .zettel-content code{margin:auto auto auto auto;font-size:100%}body div.zettel-view .zettel-content p code, li code, ol code{padding:0.2em 0.2em 0.2em 0.2em;background-color:#f5f2f0}body div.zettel-view .zettel-content pre{overflow:auto}body div.zettel-view .zettel-content dl dt{font-weight:bold}body div.zettel-view .zettel-content blockquote{background-color:#f9f9f9;border-left:solid 10px #cccccc;margin:1.5em 0px 1.5em 0px;padding:0.5em 10px 0.5em 10px}body div.zettel-view .zettel-content.raw{background-color:#dddddd}body .ui.label.zettel-tag{color:#000000}body .ui.label.zettel-tag a{color:#000000}body nav.bottomPane ul.backlinks > li{padding-bottom:0.4em;list-style-type:disc}body nav.bottomPane ul.context-list > li{list-style-type:lower-roman}body .footer-version img{-webkit-filter:grayscale(100%);-moz-filter:grayscale(100%);-ms-filter:grayscale(100%);-o-filter:grayscale(100%);filter:grayscale(100%)}body .footer-version img:hover{-webkit-filter:grayscale(0%);-moz-filter:grayscale(0%);-ms-filter:grayscale(0%);-o-filter:grayscale(0%);filter:grayscale(0%)}body .footer-version, .footer-version a, .footer-version a:visited{color:#808080}body .footer-version a{font-weight:bold}body .footer-version{margin-top:1em !important;font-size:0.69999em}@media only screen and (max-width: 768px){body div#zettel-container{margin-left:0.4em !important;margin-right:0.4em !important}}body span.zettel-link-container span.zettel-link a{color:#2185d0;font-weight:bold;text-decoration:none}body span.zettel-link-container span.zettel-link a:hover{background-color:rgba(33,133,208,0.1)}body span.zettel-link-container span.extra{color:auto}body span.zettel-link-container.errors{border:solid 1px #ff0000}body span.zettel-link-container.errors span.zettel-link a:hover{text-decoration:none !important;cursor:not-allowed}body [data-tooltip]:after{font-size:0.69999em}body div.tag-tree div.node{font-weight:bold}body div.tag-tree div.node a.inactive{color:#555555}body .tree.flipped{-webkit-transform:rotate(180deg);-moz-transform:rotate(180deg);-ms-transform:rotate(180deg);-o-transform:rotate(180deg);transform:rotate(180deg)}body .tree{overflow:auto}body .tree ul.root{padding-top:0px;margin-top:0px}body .tree ul{position:relative;padding:1em 0px 0px 0px;white-space:nowrap;margin:0px auto 0px auto;text-align:center}body .tree ul::after{content:"";display:table;clear:both}body .tree ul:last-child{padding-bottom:0.1em}body .tree li{display:inline-block;vertical-align:top;text-align:center;list-style-type:none;position:relative;padding:1em 0.5em 0em 0.5em}body .tree li::before{content:"";position:absolute;top:0px;right:50%;border-top:solid 2px #cccccc;width:50%;height:1.19999em}body .tree li::after{content:"";position:absolute;top:0px;right:50%;border-top:solid 2px #cccccc;width:50%;height:1.19999em}body .tree li::after{right:auto;left:50%;border-left:solid 2px #cccccc}body .tree li:only-child{padding-top:0em}body .tree li:only-child::after{display:none}body .tree li:only-child::before{display:none}body .tree li:first-child::before{border-style:none;border-width:0px}body .tree li:first-child::after{border-radius:5px 0px 0px 0px}body .tree li:last-child::after{border-style:none;border-width:0px}body .tree li:last-child::before{border-right:solid 2px #cccccc;border-radius:0px 5px 0px 0px}body .tree ul ul::before{content:"";position:absolute;top:0px;left:50%;border-left:solid 2px #cccccc;width:0px;height:1.19999em}body .tree li div.forest-link{border:solid 2px #cccccc;padding:0.2em 0.29999em 0.2em 0.29999em;text-decoration:none;display:inline-block;border-radius:5px 5px 5px 5px;color:#333333;position:relative;top:2px}body .tree.flipped li div.forest-link{-webkit-transform:rotate(180deg);-moz-transform:rotate(180deg);-ms-transform:rotate(180deg);-o-transform:rotate(180deg);transform:rotate(180deg)}</style><script async="" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/themes/prism.min.css" rel="stylesheet" /><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-core.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/plugins/autoloader/prism-autoloader.min.js"></script><!--replace-end-7--><!--replace-end-4--><!--replace-end-1--></head><body><div class="ui fluid container universe"><!--replace-start-2--><!--replace-start-3--><!--replace-start-6--><nav class="flipped tree deemphasized" id="zettel-uptree" style="transform-origin: 50%"><ul class="root"><li><ul><li><div class="forest-link"><span class="zettel-link-container"><span class="zettel-link"><a href="Languages.html">Languages</a></span></span></div></li></ul></li></ul></nav><div class="ui text container" id="zettel-container" style="position: relative"><div class="zettel-view"><article class="ui raised attached segment zettel-content"><div class="pandoc"><h1 id="title-h1">Grammers</h1><p>A grammer is a language for defining <a href="Languages/Languages" title="cf">languages</a>. If you write rules for a language then these rules are also called the grammar. The individual rules you write are called a production. Grammars define the structure of the <a href="Data/Sentences" title="cf">sentences</a> in the language.</p><p>A grammar consits of multiple productions. Productions can be seen as rewrite rules. If the left side matches you can replace it with the other side. Also if you already have something that is part of the language you can make more things in the language.</p><p>Formally you have:</p><ul><li>N - A finite set of non terminals (states)</li><li><span class="math inline">\(\sum\limits\)</span> - A finite set terminals, disjoint from N</li><li>P - A finite set of production rules</li><li><span class="math inline">\(S \in N\)</span> A distinguished start non terminal state from N.</li></ul><p>The symbol from the alphabeth are also called <strong>terminals</strong>. <span class="math inline">\(\epsilon\)</span> is also a terminal. Rember epsilon is the empty input.</p><p>The grammer makes use of auxiliary symbol which is called <strong>nonterminals</strong>. These are not part of the alphabet and hence cannot be part of the final word/sentence. The non terminals are supposed to be replaced with terminals when your parsing. This is called a rewrite rule. Non terminals can be of two types.</p><ul><li>Pre-terminals like PrN and V are <a href="Languages/Parts of Speech" title="cf">Languages/Parts of Speech</a>. Or atomic non-terminals. The production rules indicate which sequences they can generate.</li><li><a href="Languages/Constituency" title="cf">Constituents</a> (NP and VP) are abstract units which absolve complex syntactic functions.</li></ul><p>!<a href="images/Pasted image 20220314185901.webp" title="cf">images/Pasted image 20220314185901.webp</a></p><p>The grammer rules are kind of defined like inductive rules.</p><p>The idea is that you repalce the non terminals with a parse tree or an abstract syntax tree. This abstract syntax you can then evaluate.</p><p>The start state is nice because if you can get from an input to the start state by following the rewrite rules then you know your input is in the language. The start state represents to most abstract place in your language.</p><p>We usually read the rules left to right but you can always go back if you want.</p><h2 id="writing-down-the-rules">Writing down the rules</h2><p>There are diffent ways to write downs the rules. There are also different formats. Once such format is the <a href="Languages/Chomsky Normal Form" title="cf">Languages/Chomsky Normal Form</a>.</p><p>Also remember that the rules in a grammar for a langauage HAS to be finite. Otherwise you would also have to consider another rule.</p><p>You can use non terminals on both sides. This allows for good abstraction. This is done using <a href="Languages/Constituency" title="cf">Languages/Constituency</a>.</p><h2 id="example">Example</h2><p>If you have this grammar:</p><ul><li>A -&gt; aAa</li><li>A -&gt; bAb</li><li>A -&gt; <span class="math inline">\(\epsilon\)</span></li></ul><p>Then this word is in the language: abaaba. Because you can parse it like this:</p><ol><li>abaaba</li><li>abAba</li><li>aAa</li><li>A</li></ol><p>Usually the non terminals are capatilized.</p><h2 id="examples">Examples</h2><h2 id="palendrone-example">Palendrone example</h2><p>!<a href="images/Pasted image 20211127131012.webp" title="cf">images/Pasted image 20211127131012.webp</a></p><p>The idea is that it sort of does not matter what P is here.</p><p>When still talking about palendrome.</p><p>!<a href="images/Pasted image 20211127130856.webp" title="cf">images/Pasted image 20211127130856.webp</a></p><p>S is a start.</p><p>So you can define a grammer like this:</p><p>!<a href="images/Pasted image 20211127131455.webp" title="cf">images/Pasted image 20211127131455.webp</a></p><p>This is an example of a grammer which only allows strings of a and b.</p><p>This is a special grammer where there is only non terminal on the left. This is a <strong>Context Free</strong> grammer. If there are multiple non terminal characters than you have a context sensitive grammer.</p><p>In this course we are only looking at context free languages. There are a lot of languages that we can’t describe with this. There are also languages that you could never describe with a grammer. There are sadly more languages that you can’t describe with grammer. Most programming languages are context free.</p><p>You can also have more grammers for the same language.</p><p>!<a href="images/Pasted image 20211127131955.webp" title="cf">images/Pasted image 20211127131955.webp</a></p><p>This makes sense because the cpu also looked very different for everyone.</p><h2 id="more-exampels-with-digit">More exampels with digit</h2><p>!<a href="images/Pasted image 20211127132201.webp" title="cf">images/Pasted image 20211127132201.webp</a></p><p>Here there is one non terminal Dig that can be rewritten to each digit.</p><p>We can also now define Digs wich is atleast two digits. With this we can define any sequence of numbers.</p><p>!<a href="images/Pasted image 20211127132647.webp" title="cf">images/Pasted image 20211127132647.webp</a></p><p>So we can do Digs -&gt; Dig* to say Digs is 0 or more Dig</p><p>What about numbers that don’t start with 0?</p><p>We can make Dig-0 -&gt; 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 Then with that we can define a sequence of natural numbers like: Nat -&gt; 0 | Dig-0 | Digs</p><p>Then we can define integers by defining a sign: Sign -&gt; +|- Int -&gt; Sign Nat | Nat</p><p>This means a Int is a natural number with an optional sign. There is a short hand for this like:</p><p>Int -&gt; Sign ? Nat</p><p>This means the sign can be there but does not have to be.</p><h2 id="letters">Letters</h2><p>Letters are a lot like digits but we just have more things.</p><p>SLetter -&gt; a|b|….|z CLetter -&gt; A|B|…|Z</p><p>This also means that you before you write down the grammer you have to specify what you can use as non teminal.</p><p>Letter -&gt; SLetter | CLetter</p><p>Now we can set up something like an identifier. Like a var name.</p><p>Identifier -&gt; Letter | AphaNum* AlphaNum -&gt; Letter | Dig</p><p>You can easily exstend this with _ or othe things you want to be in identifiers. Honestly I really like this so far!</p><p>The reason we do a letter first is that this way the compiler does not get confused that something is actually a number like a Nat.</p><h1 id="fragment-of-c">Fragment of C#</h1><p>With this we can actually define the whole of C# woah.</p><p>Var -&gt; Identifier Op -&gt; Sign Stat -&gt; Var = Expr; | if (Expr) Stat else Stat | While (Expr) Stat Expr -&gt; Integer | Var | Expr Op Expr</p><h1 id="how-in-haskell">How in haskell?</h1><p>Represent the non terminals as data types.</p><p>The concrete syntax is the syntax like above the abstract is how you would define it in haskell with data types.</p><p>!<a href="images/Pasted image 20211127142739.webp" title="cf">images/Pasted image 20211127142739.webp</a></p><p>You can also take the tree and bring it back to the string.</p><p>!<a href="images/Pasted image 20211127142855.webp" title="cf">images/Pasted image 20211127142855.webp</a></p></div></article><nav class="ui attached segment deemphasized backlinksPane" id="neuron-backlinks-pane"><h3 class="ui header">Backlinks</h3><ul class="backlinks"><li><span class="zettel-link-container cf"><span class="zettel-link"><a href="parsetree.html">Parse Tree</a></span></span><ul class="context-list" style="zoom: 85%;"><li class="item"><div class="pandoc"><p>Use can use the <span class="zettel-link-container cf"><span class="zettel-link" title="Zettel: Grammers"><a href="Grammar.html">grammar</a></span></span> rules to make a path to terminals, and you can then visualize this with a parse tree.</p></div></li></ul></li></ul><h3 class="ui header"><span title="Backlinks from folgezettel parents">Uplinks</span></h3><ul class="backlinks"><li><span class="zettel-link-container folge"><span class="zettel-link"><a href="Languages.html">Languages</a><span data-nosnippet="" style="user-select: none; color: gray" title="Folgezettel">#</span></span></span><ul class="context-list" style="zoom: 85%;"><li class="item"><div class="pandoc"><em>Parent directory zettel</em></div></li></ul></li></ul></nav><nav class="ui attached segment deemphasized bottomPane" id="neuron-tags-pane"><div><span class="ui basic label zettel-tag" title="Tag">root/Languages</span></div></nav><nav class="ui bottom attached icon compact inverted menu blue" id="neuron-nav-bar"><!--replace-start-9--><!--replace-end-9--><a class="item" href="https://github.com/srid/neuron/edit/master/doc/./Languages/Grammar.md" title="Edit this page"><i class="edit icon"></i></a><a class="right item" href="impulse.html" title="Open Impulse"><i class="wave square icon"></i></a></nav></div></div><!--replace-end-6--><!--replace-end-3--><!--replace-end-2--><div class="ui center aligned container footer-version"><div class="ui tiny image"><a href="https://neuron.zettel.page"><img alt="logo" src="https://raw.githubusercontent.com/srid/neuron/master/assets/neuron.svg" title="Generated by Neuron 1.9.35.3" /></a></div></div></div></body></html>