<!DOCTYPE html><html><head><meta content="text/html; charset=utf-8" http-equiv="Content-Type" /><meta content="width=device-width, initial-scale=1" name="viewport" /><!--replace-start-0--><!--replace-start-5--><!--replace-start-8--><title>Regular expression - Neuron Zettelkasten</title><!--replace-end-8--><!--replace-end-5--><!--replace-end-0--><link href="https://cdn.jsdelivr.net/npm/fomantic-ui@2.8.7/dist/semantic.min.css" rel="stylesheet" /><link href="https://fonts.googleapis.com/css?family=Merriweather|Libre+Franklin|Roboto+Mono&amp;display=swap" rel="stylesheet" /><!--replace-start-1--><!--replace-start-4--><!--replace-start-7--><link href="https://raw.githubusercontent.com/srid/neuron/master/assets/neuron.svg" rel="icon" /><meta content="Regular expressions are a domain specific language for the consise description and parsing of regular languages." name="description" /><link href="https://neuron.zettel.page/Regular_expression.html" rel="canonical" /><meta content="Regular expression" property="og:title" /><meta content="Neuron Zettelkasten" property="og:site_name" /><meta content="article" property="og:type" /><meta content="Regular expression" property="neuron:zettel-id" /><meta content="Regular_expression" property="neuron:zettel-slug" /><meta content="root/Languages" property="neuron:zettel-tag" /><script type="application/ld+json">[{"@context":"https://schema.org","itemListElement":[{"name":"Languages","item":"https://neuron.zettel.page/Languages.html","@type":"ListItem","position":1}],"@type":"BreadcrumbList"}]</script><style type="text/css">body{background-color:#eeeeee !important;font-family:"Libre Franklin", serif !important}body .ui.container{font-family:"Libre Franklin", serif !important}body h1, h2, h3, h4, h5, h6, .ui.header, .headerFont{font-family:"Merriweather", sans-serif !important}body code, pre, tt, .monoFont{font-family:"Roboto Mono","SFMono-Regular","Menlo","Monaco","Consolas","Liberation Mono","Courier New", monospace !important}body div.z-index p.info{color:#808080}body div.z-index ul{list-style-type:square;padding-left:1.5em}body div.z-index .uplinks{margin-left:0.29999em}body .zettel-content h1#title-h1{background-color:rgba(33,133,208,0.1)}body nav.bottomPane{background-color:rgba(33,133,208,2.0e-2)}body div#footnotes{border-top-color:#2185d0}body p{line-height:150%}body img{max-width:100%}body .deemphasized{font-size:0.94999em}body .deemphasized:hover{opacity:1}body .deemphasized:not(:hover){opacity:0.69999}body .deemphasized:not(:hover) a{color:#808080 !important}body div.container.universe{padding-top:1em}body div.zettel-view ul{padding-left:1.5em;list-style-type:square}body div.zettel-view .pandoc .highlight{background-color:#ffff00}body div.zettel-view .pandoc .ui.disabled.fitted.checkbox{margin-right:0.29999em;vertical-align:middle}body div.zettel-view .zettel-content .metadata{margin-top:1em}body div.zettel-view .zettel-content .metadata div.date{text-align:center;color:#808080}body div.zettel-view .zettel-content h1{padding-top:0.2em;padding-bottom:0.2em;text-align:center}body div.zettel-view .zettel-content h2{border-bottom:solid 1px #4682b4;margin-bottom:0.5em}body div.zettel-view .zettel-content h3{margin:0px 0px 0.4em 0px}body div.zettel-view .zettel-content h4{opacity:0.8}body div.zettel-view .zettel-content div#footnotes{margin-top:4em;border-top-style:groove;border-top-width:2px;font-size:0.9em}body div.zettel-view .zettel-content div#footnotes ol > li > p:only-of-type{display:inline;margin-right:0.5em}body div.zettel-view .zettel-content aside.footnote-inline{width:30%;padding-left:15px;margin-left:15px;float:right;background-color:#d3d3d3}body div.zettel-view .zettel-content .overflows{overflow:auto}body div.zettel-view .zettel-content code{margin:auto auto auto auto;font-size:100%}body div.zettel-view .zettel-content p code, li code, ol code{padding:0.2em 0.2em 0.2em 0.2em;background-color:#f5f2f0}body div.zettel-view .zettel-content pre{overflow:auto}body div.zettel-view .zettel-content dl dt{font-weight:bold}body div.zettel-view .zettel-content blockquote{background-color:#f9f9f9;border-left:solid 10px #cccccc;margin:1.5em 0px 1.5em 0px;padding:0.5em 10px 0.5em 10px}body div.zettel-view .zettel-content.raw{background-color:#dddddd}body .ui.label.zettel-tag{color:#000000}body .ui.label.zettel-tag a{color:#000000}body nav.bottomPane ul.backlinks > li{padding-bottom:0.4em;list-style-type:disc}body nav.bottomPane ul.context-list > li{list-style-type:lower-roman}body .footer-version img{-webkit-filter:grayscale(100%);-moz-filter:grayscale(100%);-ms-filter:grayscale(100%);-o-filter:grayscale(100%);filter:grayscale(100%)}body .footer-version img:hover{-webkit-filter:grayscale(0%);-moz-filter:grayscale(0%);-ms-filter:grayscale(0%);-o-filter:grayscale(0%);filter:grayscale(0%)}body .footer-version, .footer-version a, .footer-version a:visited{color:#808080}body .footer-version a{font-weight:bold}body .footer-version{margin-top:1em !important;font-size:0.69999em}@media only screen and (max-width: 768px){body div#zettel-container{margin-left:0.4em !important;margin-right:0.4em !important}}body span.zettel-link-container span.zettel-link a{color:#2185d0;font-weight:bold;text-decoration:none}body span.zettel-link-container span.zettel-link a:hover{background-color:rgba(33,133,208,0.1)}body span.zettel-link-container span.extra{color:auto}body span.zettel-link-container.errors{border:solid 1px #ff0000}body span.zettel-link-container.errors span.zettel-link a:hover{text-decoration:none !important;cursor:not-allowed}body [data-tooltip]:after{font-size:0.69999em}body div.tag-tree div.node{font-weight:bold}body div.tag-tree div.node a.inactive{color:#555555}body .tree.flipped{-webkit-transform:rotate(180deg);-moz-transform:rotate(180deg);-ms-transform:rotate(180deg);-o-transform:rotate(180deg);transform:rotate(180deg)}body .tree{overflow:auto}body .tree ul.root{padding-top:0px;margin-top:0px}body .tree ul{position:relative;padding:1em 0px 0px 0px;white-space:nowrap;margin:0px auto 0px auto;text-align:center}body .tree ul::after{content:"";display:table;clear:both}body .tree ul:last-child{padding-bottom:0.1em}body .tree li{display:inline-block;vertical-align:top;text-align:center;list-style-type:none;position:relative;padding:1em 0.5em 0em 0.5em}body .tree li::before{content:"";position:absolute;top:0px;right:50%;border-top:solid 2px #cccccc;width:50%;height:1.19999em}body .tree li::after{content:"";position:absolute;top:0px;right:50%;border-top:solid 2px #cccccc;width:50%;height:1.19999em}body .tree li::after{right:auto;left:50%;border-left:solid 2px #cccccc}body .tree li:only-child{padding-top:0em}body .tree li:only-child::after{display:none}body .tree li:only-child::before{display:none}body .tree li:first-child::before{border-style:none;border-width:0px}body .tree li:first-child::after{border-radius:5px 0px 0px 0px}body .tree li:last-child::after{border-style:none;border-width:0px}body .tree li:last-child::before{border-right:solid 2px #cccccc;border-radius:0px 5px 0px 0px}body .tree ul ul::before{content:"";position:absolute;top:0px;left:50%;border-left:solid 2px #cccccc;width:0px;height:1.19999em}body .tree li div.forest-link{border:solid 2px #cccccc;padding:0.2em 0.29999em 0.2em 0.29999em;text-decoration:none;display:inline-block;border-radius:5px 5px 5px 5px;color:#333333;position:relative;top:2px}body .tree.flipped li div.forest-link{-webkit-transform:rotate(180deg);-moz-transform:rotate(180deg);-ms-transform:rotate(180deg);-o-transform:rotate(180deg);transform:rotate(180deg)}</style><script async="" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/themes/prism.min.css" rel="stylesheet" /><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-core.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/plugins/autoloader/prism-autoloader.min.js"></script><!--replace-end-7--><!--replace-end-4--><!--replace-end-1--></head><body><div class="ui fluid container universe"><!--replace-start-2--><!--replace-start-3--><!--replace-start-6--><nav class="flipped tree deemphasized" id="zettel-uptree" style="transform-origin: 50%"><ul class="root"><li><ul><li><div class="forest-link"><span class="zettel-link-container"><span class="zettel-link"><a href="Languages.html">Languages</a></span></span></div></li></ul></li></ul></nav><div class="ui text container" id="zettel-container" style="position: relative"><div class="zettel-view"><article class="ui raised attached segment zettel-content"><div class="pandoc"><h1 id="title-h1">Regular expression</h1><p>Regular expressions are a domain specific language for the consise description and parsing of <a href="regular%20languages.md">regular languages</a>.</p><p>Regular langues officially start and end with /. So you have /regular expression/. Often you leave these / out.</p><p>So let’s have a regular expression for god. The regular expression is /god/.</p><p>The grammar for this language looks like this:</p><ul><li>S -&gt; gA</li><li>A → oB</li><li>B → d</li></ul><p>Regular languages can be expressions in regular expressions which can be expressed in <a href="finite%20state%20automata.md">finite state automata</a>. This is great because this makes regular expressions really fast to parse.</p><h2 id="symbols">Symbols</h2><p>You can parse symbols at a position by just including them in the regular expression /hello/ parses the word hello. But what if we want to parse multiple words. Then we have to define a regular expression where one position of the sentence can have multiple symbols. This is done with character ranges.</p><h3 id="symol-ranges">Symol Ranges</h3><p>Now you can have groups at any position. So if we want to pare: [god, bod] then we can have a regular expression like this: /[gb]od/. This is like having a regular grammar rule like this.</p><ul><li>S -&gt; gA</li><li>S -&gt; bA</li><li>A → oB</li><li>B → d</li></ul><p>There is special syntax for ranges /[a-z]od/ here we can parse any lowercase letter of the alphabeth followed by od. These ranges are defined by the aski number of the symbol which happens to be confinient. Some common ranges:</p><ul><li>[A-z] is all letters lowercase uppercase</li><li>[0-9] is all numbers 0 to 9</li><li>[4-7] is all numbers 7 to 7.</li></ul><h3 id="the-wildcard">The wildcard</h3><p>If you don’t care what the symbol of a position in the word is then you can use the . wildcard. So /h.i/ can match hai hoi hbi etc. The only thing the . does not match with is a newline character. This is like an enter.</p><h3 id="negation">Negation</h3><p>If you use ^ at the start of a character range than everything that is not this range matched. So you you say [^{0-4] then everything that is not in <span class="math inline">\(\set{0,1,2,3,4}\)</span> is parsed.</p><h2 id="counters-repeating">Counters (repeating)</h2><h3 id="zero-or-once">Zero or once</h3><p>Sometimes you have something optional that can occure or not. For instance in someone’s last name. This is also sometimes called the optional.</p><h3 id="one-or-more">One or more</h3><p>If sometimg has to ocure once or more than we can use the +.</p><p>So /so+/ will parse so, soooo, sooo but not s because o has to appear atleast once.</p><h3 id="zero-or-more">Zero or more</h3><p>Sometimes you want to check that the same part repeats sometimes. You can just define that like this: /aaaao/ but what if you don’t know how often the a will appear? Then there are special symbols for this. /a* o/ will parse a string that starts with zero or more a’s followed by a space followed by an o.</p><p>This is for instance how we can pase so and sooooo as the same word. /so*/ However this also parses s because * means zero or more.</p><h3 id="custom-repeat">Custom repeat</h3><p>You can also define custom ranges. If we only want to parse a so with 4 to 10 o then we can say /so{4,10}/. The ? is a shortcut for {0,1}. If you have {n,m} n is the minimum number it has to appear and m is the maximum it can appear.</p><h3 id="combining-with-symbol-ranges">Combining with symbol ranges</h3><p>You can use +, * , ? and {} with character ranges aswell. So you can say /age:[0-9]{1,3}/ to parse any string like: “age:32” or “age:120”.</p><p>Or lets say /d[a-z]+d/. This parses any string starting and ending with a d with one or more lowercase letter in between them.</p><h2 id="markers-end-and-start-of-the-line">Markers (End and start of the line)</h2><p>^ can also mean start of the string where $ means end of the string line. Ths is based on newline characters.</p><h2 id="escaping">Escaping</h2><p>So far we defined special characters like . ? * + {} [] and there are more like ^{ and $ which mean end of string start of string or ^ can also mean negation. However maybe you want to literally check for these characters. When you want this you have to put \ before the special character to indicate this. So you could use /.+./ to check if sentences end with a string. The . is escaped here. Or what if you want to check for something like [1,2,3,4] then you have to do /\[[0-9,]*\]/. Basically you want to literally check for the [ and ] characters. Note that this also matches [,9,9,9]\ we need groups. to fix this.</p><h3 id="special-escapes">Special escapes</h3><p>If you escape things that are letters so only a literal meaning you get oposite. So \n is a new line (very common thing). But \t is a tab or \b is a word boundary for instance. A word bounary is anything that is not a letter, digit or underscore. Often the oposite of this selection is the capital version of this so \B only match word bounardy. These can be very usefull. You can also use these special escapes in ranges like: [\b] is the same as [A-z0-9_] is the same as \b.</p><h2 id="grouping">Grouping</h2><p>Often you want to repeat longer productions. In this case you can use groups. A group is (). So you can say (ha)+ which means the string ha repeated. So that can match ha, haha, hahaha, but not hah. These groups can contain anything we defined before, so you can have something like:</p><p>/\[([0-9],)*\]/ which matches [] and also [1,2,4,]</p><p>The point of grouping is that it involves multiple characters.</p><h3 id="capture-groups">Capture groups</h3><p>Any time you define a group you can refere back to it by using the index with a \ in front. The index is just the number that you defined the group as.</p><p>So if you have /a(b)\1/ then this matches abb. You repeat the group with the b again. You could also have /(a)(b)\2\1/ this would match abba.</p><p>Now this is the thing what the \1 has to match what you found in the group! So if you you define /my_age:([0-9]{1-3})-I_am_\1_years_old\./ Then this can match: my_age:12,I_am_12_years_old. But it couldn’t match my_age:12,I_am_33_years_old. Because the capture group and the referal back to it are not the same! So the result is really stored in memory. This is also great if you want to get the results of the group later.</p><h2 id="actions">Actions</h2><h3 id="substitution-replace">Substitution (replace)</h3><p>If you start your regular expresion with an s you define a replacement. Something like this for instance replaces one or more white spaces with a tab.</p><p><code>s/ +/\t/</code> The s indicates replace the first block by the second block. The block is defined by what’s between the / / .</p><p>You can add a g at the end to do this everywhere. This means global. So then you get <code>s/ +/\t/g</code>.</p><p>Or lets say you have: s/[0-9]/|number|/g this would replace:</p><p>Counting goes like 1,2,3,4,5! with Counting goes like |number|,|number|,|number|,|number|,|number|!</p><p>If you don’t have the g it would go to:</p><p>Counting goes like |number|,2,3,4,5!</p><p>You can also replace by capture group!</p><h1 id="oniline-resources">Oniline resources</h1><p>You can use websites to test your regular expressions. For instance this one is usefull:</p><p><a href="https://regex101.com">https://regex101.com</a></p><p>Play around with it.</p><h1 id="example-of-email-regex">Example of email regex</h1><pre><code class="language-none">(?:[a-z0-9!#$%&amp;&#39;*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&amp;&#39;*+/=?^_`{|}~-]+)*|&quot;(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21\x23-\x5b\x5d-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])*&quot;)@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*[a-z0-9]:(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21-\x5a\x53-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])+)\])</code></pre><p>This one works for 99.99 % of all emails.</p></div></article><nav class="ui attached segment deemphasized backlinksPane" id="neuron-backlinks-pane"><h3 class="ui header"><span title="Backlinks from folgezettel parents">Uplinks</span></h3><ul class="backlinks"><li><span class="zettel-link-container folge"><span class="zettel-link"><a href="Languages.html">Languages</a><span data-nosnippet="" style="user-select: none; color: gray" title="Folgezettel">#</span></span></span><ul class="context-list" style="zoom: 85%;"><li class="item"><div class="pandoc"><em>Parent directory zettel</em></div></li></ul></li></ul></nav><nav class="ui attached segment deemphasized bottomPane" id="neuron-tags-pane"><div><span class="ui basic label zettel-tag" title="Tag">root/Languages</span></div></nav><nav class="ui bottom attached icon compact inverted menu blue" id="neuron-nav-bar"><!--replace-start-9--><!--replace-end-9--><a class="item" href="https://github.com/srid/neuron/edit/master/doc/./Languages/Regular expression.md" title="Edit this page"><i class="edit icon"></i></a><a class="right item" href="impulse.html" title="Open Impulse"><i class="wave square icon"></i></a></nav></div></div><!--replace-end-6--><!--replace-end-3--><!--replace-end-2--><div class="ui center aligned container footer-version"><div class="ui tiny image"><a href="https://neuron.zettel.page"><img alt="logo" src="https://raw.githubusercontent.com/srid/neuron/master/assets/neuron.svg" title="Generated by Neuron 1.9.35.3" /></a></div></div></div></body></html>